# 计算机网络

## TCP如何保证可靠传输？

1. **三次握手**
2. **确认应答和超时重传**
3. **数据校验**：接收方会缓存未按序到达的数据，重新排序后再交给应用层。

4. **数据合理分片和排序**：接收方会缓存未按序到达的数据，重新排序后再交给应用层。

5. **流量控制**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。
6. **拥塞控制**：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

## TCP 是如何通过滑动窗口协议实现==流量控制==和==拥塞控制==的？

通过调节窗口的大小

窗口指的是一次批量的发送多少数据（**缓冲区**）

在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样做有一个比较大的缺点，就是性能比较差，尤其是数据往返的时间长的时候，使用滑动窗口，就可以一次发送多条数据，从而就提高了性能

## TCP滑动窗口协议

用于网络数据传输时的流量控制，拥塞控制。该协议可以加速数据的传输，提高网络的吞吐量。

TCP滑动窗口是以字节为单位的，发送方的发送窗口是根据接收方窗口设置的

> 可靠性，滑动窗口只有在队列前部的被确认之后，才会往后移动，保证数据包被接收方确认并接收。
>
> 提高传输效率
>
> 稳定性，滑动窗口大小，会进行动态调整，可以尽量地避免网络拥塞，更加稳定。

## TCP三次握手 四次挥手

TCP 的三次握手过程如下：
C-> SYN -> S
S->SYN/ACK->C
C->ACK->S

TCP 的四次挥手过程如下：
C->FIN->S
S->ACK->C
S->FIN->C
C->ACK->S

## 数据库：创建一个表，增删改查

create table

insert into 表名(字段名1,字段名2,字段名3……) values(值1,值2,值3……)

delete from 表名

select * from 表名

update 表名 set 字段名=值, 字段名=值, 字段名=值……

# 操作系统

## 进程和线程的区别

* **概念**：进程是**CPU资源分配**的**最小单位**，线程是**CPU调度**的**最小单位**。
* **系统资源**：进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。线程创建销毁内存开销大
* **通信**：进程间通信比较复杂，而同一进程的线程由于共享代码段和数据段，所以通信比较容易，进程通信效率相比较线程通信效率低
* **程序可靠性**：一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。
* **调试**：多进程编程相比较多线程调试简单，Bug也会容易找

## 阻塞，非阻塞，同步，异步的异同

阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。

同步和异步：调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步

## 死锁产生的原因及四个必要条件

[死锁产生的条件和解决死锁的方法_风格色的博客-CSDN博客](https://blog.csdn.net/qq_27068845/article/details/78818381)

[[c++11\]多线程编程(四)——死锁(Dead Lock) - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000016217199)

[c++ Programming - Bo Qian's Space](https://boqian.weebly.com/c-programming.html)

**死锁概念**：死锁指的是两个或两个以上的进程或线程因争夺资源而相互等待**阻塞**的情形

**产生死锁的原因主要是**：

1. 因为系统资源不足。
2. 进程运行推进的顺序不合适。
3. 资源分配不当等。

**产生死锁的四个必要条件**：

1. 互斥条件，进程分配到的资源不允许其他进程访问
2. 请求保持，进程分配到资源后，不释放自己的资源还要请求其他被人家占有的资源
3. 不可剥夺，进程已有的资源，其他进程不可抢夺
4. 循环等待，进程互相等待资源

**避免死锁**：

- 每个线程只持有一个锁， 锁上就不会产生死锁。
- 避免在持有锁时调用用户提供的代码。不要在互斥锁保护的区域使用用户自定义的代码，因为用户的代码可能操作了其他的互斥锁。
- 如果想同时对多个互斥锁上锁，要使用`std::lock()`
- 使用固定顺序获取锁（比较地址），或者使用层次锁
  - 可以比较`mutex`的地址，每次都先锁地址小的	
  - 使用层次锁，将互斥锁包装一下，给锁定义一个层次的属性，每次按层次由高到低的顺序上锁。

**死锁检测**：

死锁检测算法：当任一进程申请一个已被其他进程占有的资源时，通过反复查找资源分配表和进程等待表 ，来确定该进程对这个资源的申请是否会导致环路，若是，便确定出现死锁。

1. 等待获得锁自旋超过2微秒时间后开始检测是否发生了死锁
2. 建立资源分配表，为每个进程和每个资源指定一个唯一的号码，表中包含“资源号”和占有该资源的“进程号”两项。（**有向图的环判断问题**）
3. 进程等待表

# C/C++程序基础

## 指针和数组的区别

## C++多线程优化

OpenMP Boost OpenBLAS SIMD 浮点转定点

## GCC编译优化选项

gcc -O0 -O1 -O2 -O3 四级优化选项

- O1优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。 
- O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。 
- O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。 
- Os主要是对代码大小的优化，我们基本不用做更多的关心。 通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。 

## 字节对齐

## 构造函数能否为虚函数

构造函数不能为虚函数