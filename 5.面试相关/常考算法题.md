## 反转链表

双指针

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead==NULL||pHead->next==NULL)
            return pHead;
        ListNode* pre = NULL;
        ListNode* cur = pHead;
        ListNode* p;
        while(cur)
        {
            p = cur->next;
            cur->next = pre;
            pre = cur;
            cur = p;
        }
        return pre;
    }
};
```

```
class Solution:
    def ReverseList(self, pHead):
        pre = None
        cur = pHead
        while cur!=None:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre
```

## LRU缓存结构

1. put（set）放入永远放在第一个，放入时要考虑是否已经存满，若存满需要删除最后一个
2. get需要值移动到第一个，若找不到返回-1
3. 采用的数据结构为有序的Dict

```python
import collections
class Solution:
    def __init__(self, k):
        self.dic = collections.OrderedDict()
        self.capacity = k
    def get(self, key):
        if key not in self.dic:
            return -1
        # 采取先pop再往里面添加
        val = self.dic.pop(key)
        self.dic[key] = val
        return val
   
	def set(self, key, value):
        if key in self.dic:
            self.dic.pop(key)
        else:
            if self.capacity > 0:
                self.capacity -= 1
            else:
                self.dic.popitem(last=False)
        self.dic[key] = value
```



## 判断一个链表是否有环

## 最小栈

* [155. 最小栈 - 力扣（LeetCode）](https://leetcode-cn.com/problems/min-stack/)

方法一：建立两个栈，一个栈中存储最小值、一个栈中存储原始数据。需要注意如果有同样的最小值入栈的状况，因此可以采取只要有数据入栈就把最小值再压入

![fig1](https://assets.leetcode-cn.com/solution-static/155/155_fig1.gif)

## 随机数