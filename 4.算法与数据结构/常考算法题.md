> [牛客题霸-名企高频面试题_牛客网](https://www.nowcoder.com/ta/job-code-high-week)

[TOC]



## 反转链表（双指针）

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

```python
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def ReverseList(self, pHead):
        pre = None
        cur = pHead
        while cur!=None:
            temp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre
```

![image-20210521202035078](image/image-20210521202035078.png)

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = NULL;
        ListNode* cur = head;
        while (cur!=NULL) {
            ListNode* next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
};
```



## 最小的K个数（排序、快排、堆）

* 排序

  ```python
  class Solution:
      def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
          if arr == [] or k > len(arr):
              return []
          arr.sort()
          return arr[:k]
  ```

  ```c++
  class Solution {
  public:
      vector<int> getLeastNumbers(vector<int>& arr, int k) {
          vector<int> vec(k, 0);
          sort(arr.begin(), arr.end());
          for (int i = 0; i < k; ++i) {
              vec[i] = arr[i];
          }
          return vec;
      }
  };
  ```

* 快排

  ```python
  #该方法与常规排序一样
  class Solution:
      def GetLeastNumbers_Solution(self, tinput, k):
          def quick_sort(lst):
              if not lst:
                  return []
              pivot = lst[0]
              left = quick_sort([x for x in lst[1: ] if x < pivot])
              right = quick_sort([x for x in lst[1: ] if x >= pivot])
              return left + [pivot] + right
   
          if tinput == [] or k > len(tinput):
              return []
          tinput = quick_sort(tinput)
          return tinput[: k]
  ```

   partition方法（改造版快速排序）

  快速排序的思想是将数据分成两个部分，左边的小于基础数，右面的大于基础数，如果基础数的坐标 i 恰好等于 k，那么我们就可以确定 arr[:k]就是我们的解

  ```
  
  ```

  

